# amcl:
#   ros__parameters:
#     use_sim_time: True
#     alpha1: 0.2
#     alpha2: 0.2
#     alpha3: 0.2
#     alpha4: 0.2
#     alpha5: 0.2
#     base_frame_id: "base_link"
#     beam_skip_distance: 0.5
#     beam_skip_error_threshold: 0.9
#     beam_skip_threshold: 0.3
#     do_beamskip: false
#     global_frame_id: "map"
#     lambda_short: 0.1
#     laser_likelihood_max_dist: 2.0
#     laser_max_range: 100.0
#     laser_min_range: -1.0
#     laser_model_type: "likelihood_field"
#     max_beams: 60
#     max_particles: 2000
#     min_particles: 500
#     odom_frame_id: "base_link"
#     pf_err: 0.05
#     pf_z: 0.99
#     recovery_alpha_fast: 0.0
#     recovery_alpha_slow: 0.0
#     resample_interval: 1
#     robot_model_type: "nav2_amcl::OmniMotionModel"
#     save_pose_rate: 0.5
#     sigma_hit: 0.2
#     tf_broadcast: true
#     transform_tolerance: 1.0
#     update_min_a: 0.2
#     update_min_d: 0.25
#     z_hit: 0.5
#     z_max: 0.05
#     z_rand: 0.5
#     z_short: 0.05
#     # at sensor frame
#     scan_topic: registered_scan

bt_navigator:
  ros__parameters:
    use_sim_time: True
    global_frame: map
    robot_base_frame: base_link
    odom_topic: state_estimation
    bt_loop_duration: 10
    default_server_timeout: 20
    # 'default_nav_through_poses_bt_xml' and 'default_nav_to_pose_bt_xml' are use defaults:
    # nav2_bt_navigator/navigate_to_pose_w_replanning_and_recovery.xml
    default_nav_through_poses_bt_xml: /home/sentry_ws/src/sentry_bringup/behavior_tree/navigate_through_pose_w_replanning_and_recovery.xml
    default_nav_to_pose_bt_xml: /home/sentry_ws/src/sentry_bringup/behavior_tree/navigate_to_pose_w_replanning_and_recovery.xml
    # They can be set here or via a RewrittenYaml remap from a parent launch file to Nav2.
    plugin_lib_names:
      - nav2_compute_path_to_pose_action_bt_node
      - nav2_compute_path_through_poses_action_bt_node
      - nav2_smooth_path_action_bt_node
      - nav2_follow_path_action_bt_node
      - nav2_spin_action_bt_node
      - nav2_wait_action_bt_node
      - nav2_assisted_teleop_action_bt_node
      - nav2_back_up_action_bt_node
      - nav2_drive_on_heading_bt_node
      - nav2_clear_costmap_service_bt_node
      - nav2_is_stuck_condition_bt_node
      - nav2_goal_reached_condition_bt_node
      - nav2_goal_updated_condition_bt_node
      - nav2_globally_updated_goal_condition_bt_node
      - nav2_is_path_valid_condition_bt_node
      - nav2_initial_pose_received_condition_bt_node
      - nav2_reinitialize_global_localization_service_bt_node
      - nav2_rate_controller_bt_node
      - nav2_distance_controller_bt_node
      - nav2_speed_controller_bt_node
      - nav2_truncate_path_action_bt_node
      - nav2_truncate_path_local_action_bt_node
      - nav2_goal_updater_node_bt_node
      - nav2_recovery_node_bt_node
      - nav2_pipeline_sequence_bt_node
      - nav2_round_robin_node_bt_node
      - nav2_transform_available_condition_bt_node
      - nav2_time_expired_condition_bt_node
      - nav2_path_expiring_timer_condition
      - nav2_distance_traveled_condition_bt_node
      - nav2_single_trigger_bt_node
      - nav2_goal_updated_controller_bt_node
      - nav2_is_battery_low_condition_bt_node
      - nav2_navigate_through_poses_action_bt_node
      - nav2_navigate_to_pose_action_bt_node
      - nav2_remove_passed_goals_action_bt_node
      - nav2_planner_selector_bt_node
      - nav2_controller_selector_bt_node
      - nav2_goal_checker_selector_bt_node
      - nav2_controller_cancel_bt_node
      - nav2_path_longer_on_approach_bt_node
      - nav2_wait_cancel_bt_node
      - nav2_spin_cancel_bt_node
      - nav2_back_up_cancel_bt_node
      - nav2_assisted_teleop_cancel_bt_node
      - nav2_drive_on_heading_cancel_bt_node
      - nav2_is_battery_charging_condition_bt_node

bt_navigator_navigate_through_poses_rclcpp_node:
  ros__parameters:
    use_sim_time: True

bt_navigator_navigate_to_pose_rclcpp_node:
  ros__parameters:
    use_sim_time: True

controller_server:
  ros__parameters:
    use_sim_time: True
    controller_frequency: 10.0
    min_x_velocity_threshold: 0.05
    min_y_velocity_threshold: 0.05
    min_theta_velocity_threshold: 0.1
    failure_tolerance: 0.3
    odom_topic: "state_estimation"
    progress_checker_plugin: "progress_checker"
    goal_checker_plugins: ["general_goal_checker"] 
    controller_plugins: ["FollowPath"]
    # Progress checker parameters
    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      required_movement_radius: 0.5
      movement_time_allowance: 3.0
    # Goal checker parameters
    general_goal_checker:
      stateful: False
      plugin: "nav2_controller::SimpleGoalChecker"
      xy_goal_tolerance: 0.2
      yaw_goal_tolerance: 3.14
    FollowPath:    
      # plugin: "nav2_mppi_controller::MPPIControllerExt"
      # #param 
      # adjustThre: 10.0
      # minAngleDiff: 360.0
      # adjustHeadingSpeed: 0.2
      # # 
      # time_steps: 56 # prediction horizon = time_steps x model_dt = 3s
      # model_dt: 0.05 # =1/controller_frequency
      # batch_size: 2000 # Count of randomly sampled candidate trajectories from current optimal control sequence in a given iteration. 1000 @ 50 Hz or 2000 @ 30 Hz seems to produce good results.
      # vx_std: 0.3 # prediction horizon x vx_std = 3m -->local costmap dim should larger than 3x2=6m
      # vy_std: 0.3
      # wz_std: 0.1
      # vx_max: 0.5
      # vx_min: -0.5
      # vy_max: 0.5
      # wz_max: 0.1
      # iteration_count: 1 # Recommended to remain as 1 and instead prefer larger batch sizes.
      # prune_distance: 3.0
      # transform_tolerance: 0.1
      # temperature: 0.3 # 0 mean use control with best cost, huge value will lead to just taking mean of all trajectories without cost consideration.
      # gamma: 0.065 # A trade-off between smoothness (high) and low energy (low). This is a complex parameter that likely won’t need to be changed from the default.
      # motion_model: "Omni"
      # visualize: false # set to true to visualize the trajectories, but it will slow down the computation by a lot
      # reset_period: 1.0 # Required time of inactivity to reset optimizer (only in Humble
      # regenerate_noises: false
      # retry_attempt_limit: 3 # Number of attempts to find feasible trajectory on failure for soft-resets before reporting total failure.
      # TrajectoryVisualizer:
      #   trajectory_step: 5
      #   time_step: 3
      # # AckermannConstraints:
      # #   min_turning_r: 0.2
      # critics: ["ObstaclesCritic","GoalCritic", "PathAlignCritic", "PathFollowCritic", "PreferForwardCritic","TwirlingCritic"]
      # GoalCritic:
      #   enabled: true
      #   cost_power: 1
      #   cost_weight: 5.0
      #   threshold_to_consider: 0.2
      # PreferForwardCritic: # moving in the forward direction, rather than reversing.
      #   enabled: false
      #   cost_power: 1
      #   cost_weight: 5.0
      #   threshold_to_consider: 0.5 # Distance (m) between robot and goal to stop considering preferring forward and allow goal critics to take over.
      # ObstaclesCritic: # 如果容易撞到低矮的障碍物，检查地形分析是否正确然后再调整这个参数
      #   enabled: true
      #   cost_power: 1
      #   repulsion_weight: 0.4 # Higher radii should correspond to reduced repulsion_weight due to the penalty formation (e.g. inflation_radius - min_dist_to_obstacle). 
      #   critical_weight: 10.0 # #? proprtional to your inflation layer’s radius. Higher radii should correspond to reduced repulsion_weight due to the penalty formation (e.g. inflation_radius - min_dist_to_obstacle).
      #   consider_footprint: false # switch on this can increase computation cost
      #   collision_cost: 10.0
      #   collision_margin_distance: 0.1 # 0.05 # Margin distance (m) from collision to apply severe penalty, similar to footprint inflation. Between 0.05-0.2 is reasonable. Note that it will highly influence the controller not to enter spaces more confined than this, so ensure this parameter is set lower than the narrowest you expect the robot to need to traverse through.
      #   near_goal_distance: 0.1 # if the robot is within this distance of the goal, it will not be repelled by obstacles.
      #   inflation_radius: 5.0 # Radius to inflate costmap around lethal obstacles. This should be the same as for your inflation layer (Humble only)
      #   cost_scaling_factor: 3.0 # Exponential decay factor across inflation radius. This should be the same as for your inflation layer (Humble only)
      #   inflation_layer_name: ["local_inflation_layer"] # ,"global_inflation_layer"
      # PathAlignCritic:
      #   enabled: true
      #   cost_power: 1
      #   cost_weight: 14.0
      #   max_path_occupancy_ratio: 0.05
      #   trajectory_point_step: 3
      #   threshold_to_consider: 0.5 # Distance (m) between robot and goal to stop considering path alignment and allow goal critics to take over. Should be set to a value slightly larger than your robot’s footprint radius.
      #   # TODO: what is the value of path_resolution? 0.2 maybe?
      #   offset_from_furthest: 13 # number of path points a trajectory passes through while tracking the path
      #   # prediction_horizon_s * max_speed / path_resolution / 3.0 is a good baseline.
      #   # 3 * 2.5 / 0.2 / 3.0 =
      #   use_path_orientations: false
      # PathFollowCritic: # incentivizes making progress along the path
      #   enabled: true
      #   cost_power: 1
      #   cost_weight: 5.0
      #   offset_from_furthest: 5
      #   threshold_to_consider: 0.1 #That is to say, path following will be considered until the robot is within this distance of the goal, at which point the goal critic will take over.
      # PathAngleCritic: # This critic penalizes trajectories at a high relative angle to the path. This helps the robot make sharp turns when necessary due to large accumulated angular errors.
      #   enabled: false
      #   cost_power: 1
      #   cost_weight: 2.0
      #   offset_from_furthest: 4
      #   threshold_to_consider: 0.5
      #   max_angle_to_furthest: 1.0
      #   mode: 0
      # TwirlingCritic:
      #   enabled: true
      #   twirling_cost_power: 1
      #   twirling_cost_weight: 10.0
      # plugin: "nav2_regulated_pure_pursuit_controller::RegulatedPurePursuitController"
      # desired_linear_vel: 0.5
      # lookahead_dist: 0.6
      # min_lookahead_dist: 0.3
      # max_lookahead_dist: 0.9
      # lookahead_time: 1.5
      # rotate_to_heading_angular_vel: 1.8
      # transform_tolerance: 0.1
      # use_velocity_scaled_lookahead_dist: false
      # min_approach_linear_velocity: 0.05
      # approach_velocity_scaling_dist: 0.6
      # use_collision_detection: true
      # max_allowed_time_to_collision_up_to_carrot: 1.0
      # use_regulated_linear_velocity_scaling: true
      # use_fixed_curvature_lookahead: false
      # curvature_lookahead_dist: 0.25
      # use_cost_regulated_linear_velocity_scaling: false
      # regulated_linear_scaling_min_radius: 0.9
      # regulated_linear_scaling_min_speed: 0.25
      # use_rotate_to_heading: false
      # allow_reversing: true
      # rotate_to_heading_min_angle: 0.785
      # max_angular_accel: 3.2
      # max_robot_pose_search_dist: 10.0
      plugin: "dwb_core::DWBLocalPlanner"
      debug_trajectory_details: False
      min_vel_x: -1.0
      min_vel_y: -1.0
      max_vel_x: 1.0
      max_vel_y: 1.0
      max_vel_theta: 5.0
      min_speed_xy: -5.0
      max_speed_xy: 3.0
      min_speed_theta: -5.0
      acc_lim_x: 3.0
      acc_lim_y: 3.0
      acc_lim_theta: 10.0
      decel_lim_x: -3.0
      decel_lim_y: -3.0
      decel_lim_theta: -10.0
      vx_samples: 20
      vy_samples: 20
      vtheta_samples: 20
      sim_time: 0.51
      linear_granularity: 0.05
      angular_granularity: 0.025
      transform_tolerance: 0.2
      xy_goal_tolerance: 0.25
      trans_stopped_velocity: 0.25
      short_circuit_trajectory_evaluation: True
      stateful: True
      critics: ["RotateToGoal", "Oscillation", "BaseObstacle", "GoalAlign", "PathAlign", "PathDist", "GoalDist"]
      BaseObstacle.scale: 0.02
      PathAlign.scale: 32.0
      PathAlign.forward_point_distance: 0.1
      GoalAlign.scale: 24.0
      GoalAlign.forward_point_distance: 0.1
      PathDist.scale: 32.0
      GoalDist.scale: 24.0
      RotateToGoal.scale: 32.0
      RotateToGoal.slowing_factor: 5.0
      RotateToGoal.lookahead_time: -1.0

local_costmap:
  local_costmap:
    ros__parameters:
      update_frequency: 10.0
      publish_frequency: 10.0
      global_frame: map
      robot_base_frame: base_link
      use_sim_time: True
      rolling_window: true
      width: 7
      height: 7
      resolution: 0.05
      robot_radius: 0.1
      plugins: ["local_obstacle_layer", "local_inflation_layer"]
      local_inflation_layer:
        # This layer places an exponential decay functions around obstacles to 
        # increase cost to traverse near collision. It also places a lethal cost 
        # around obstacles within the robot’s fully inscribed radius - even if a 
        # robot is non-circular for optimized first-order collision checking.
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0
        inflation_radius: 5.0
      local_obstacle_layer:
        plugin: "costmap_intensity::ObstacleLayerIntensity"
        enabled: True
        footprint_clearing_enabled: True
        max_obstacle_intensity: 2.0
        min_obstacle_intensity: 0.2
        observation_sources: pointcloud
        pointcloud:  # no frame set, uses frame from message
          topic: /terrain_map
          max_obstacle_height: 2.0
          min_obstacle_height: -2.0
          obstacle_max_range: 5.0
          obstacle_min_range: 0.2
          raytrace_max_range: 8.0
          raytrace_min_range: 0.2
          clearing: True
          marking: True
          data_type: "PointCloud2"
      # local_obstacle_layer:
      #   plugin: "nav2_costmap_2d::ObstacleLayer"
      #   enabled: True
      #   footprint_clearing_enabled: True
      #   max_obstacle_height: 2.0
      #   min_obstacle_height: -0.5
      #   combination_method: 1
      #   observation_sources: pointcloud
      #   pointcloud:  # no frame set, uses frame from message
      #     topic: /segmentation/obstacle
      #     max_obstacle_height: 2.0
      #     min_obstacle_height: -0.5
      #     obstacle_max_range: 5.0
      #     obstacle_min_range: 0.2
      #     raytrace_max_range: 8.0
      #     raytrace_min_range: 0.2
      #     clearing: True
      #     marking: True
      #     data_type: "PointCloud2"
      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: True
      always_send_full_costmap: True

global_costmap:
  global_costmap:
    ros__parameters:
      update_frequency: 1.0
      publish_frequency: 1.0
      global_frame: map
      robot_base_frame: base_link
      use_sim_time: True
      # footprint: [ [0.1, 0.1], [0.1, -0.1], [-0.1, -0.1], [-0.1, 0.1] ]
      robot_radius: 0.1
      resolution: 0.1
      track_unknown_space: true
      plugins: ["static_layer", "global_inflation_layer"] # "global_obstacle_layer", 
      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: True
      global_inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0
        inflation_radius: 5.0
      always_send_full_costmap: True
      # global_obstacle_layer:
      #   plugin: "costmap_intensity::ObstacleLayerIntensity"
      #   enabled: True
      #   footprint_clearing_enabled: True
      #   max_obstacle_intensity: 2.0
      #   min_obstacle_intensity: 0.2
      #   observation_sources: pointcloud
      #   pointcloud:
      #     topic: /terrain_map_ext
      #     max_obstacle_height: 2.0
      #     min_obstacle_height: -2.0
      #     obstacle_max_range: 2.5
      #     obstacle_min_range: 0.0
      #     raytrace_max_range: 3.0
      #     raytrace_min_range: 0.0
      #     clearing: True
      #     marking: True
      #     data_type: "PointCloud2"
      #     inf_is_valid: false


map_server:
  ros__parameters:
    use_sim_time: True
    # Overridden in launch by the "map" launch configuration or provided default value.
    # To use in yaml, remove the default "map" value in the tb3_simulation_launch.py file & provide full path to map below.
    yaml_filename: "/home/sentry_ws/src/sentry_bringup/maps/test_map.yaml"

map_saver:
  ros__parameters:
    use_sim_time: True
    save_map_timeout: 5.0
    free_thresh_default: 0.25
    occupied_thresh_default: 0.65
    map_subscribe_transient_local: True

planner_server:
  ros__parameters:
    expected_planner_frequency: 10.0
    use_sim_time: True
    planner_plugins: ["GridBased"]
    GridBased:
      # Dijkstra or A*
      # plugin: "nav2_navfn_planner/NavfnPlanner"
      # tolerance: 0.5
      # use_astar: false
      # allow_unknown: true

      # 2D A*
      # plugin: "nav2_smac_planner/SmacPlanner2D"
      # tolerance: 0.125                      # tolerance for planning if unable to reach exact pose, in meters
      # downsample_costmap: false             # whether or not to downsample the map
      # downsampling_factor: 1                # multiplier for the resolution of the costmap layer (e.g. 2 on a 5cm costmap would be 10cm)
      # allow_unknown: true                   # allow traveling in unknown space
      # max_iterations: 1000000               # maximum total iterations to search for before failing (in case unreachable), set to -1 to disable
      # max_on_approach_iterations: 1000      # maximum number of iterations to attempt to reach goal once in tolerance
      # max_planning_time: 2.0                # max time in s for planner to plan, smooth
      # cost_travel_multiplier: 2.0           # Cost multiplier to apply to search to steer away from high cost areas. Larger values will place in the center of aisles more exactly (if non-`FREE` cost potential field exists) but take slightly longer to compute. To optimize for speed, a value of 1.0 is reasonable. A reasonable tradeoff value is 2.0. A value of 0.0 effective disables steering away from obstacles and acts like a naive binary search A*.
      # use_final_approach_orientation: false # Whether to set the final path pose at the goal's orientation to the requested orientation (false) or in line with the approach angle so the robot doesn't rotate to heading (true)
      # smoother:
      #   max_iterations: 1000
      #   w_smooth: 0.3
      #   w_data: 0.2
      #   tolerance: 1.0e-10

      # Theta*
      plugin: "nav2_theta_star_planner/ThetaStarPlanner"
      how_many_corners: 8
      w_euc_cost: 1.0
      w_traversal_cost: 2.0
      w_heuristic_cost: 1.0

# smoother_server:
#   ros__parameters:
#     use_sim_time: True
#     robot_base_frame: base_link
#     smoother_plugins: ["simple_smoother"]
#     simple_smoother:
#       plugin: "nav2_smoother::SimpleSmoother"
#       tolerance: 1.0e-10
#       max_its: 1000
#       do_refinement: True

behavior_server:
  ros__parameters:
    costmap_topic: local_costmap/costmap_raw
    footprint_topic: local_costmap/published_footprint
    cycle_frequency: 10.0
    behavior_plugins: ["spin", "backup", "drive_on_heading", "assisted_teleop", "wait"]
    spin:
      plugin: "nav2_behaviors/Spin"
    backup:
      plugin: "nav2_behaviors/BackUpTwzFree"
    drive_on_heading:
      plugin: "nav2_behaviors/DriveOnHeading"
    wait:
      plugin: "nav2_behaviors/Wait"
    assisted_teleop:
      plugin: "nav2_behaviors/AssistedTeleop"
    global_frame: map
    robot_base_frame: base_link
    transform_tolerance: 0.1
    use_sim_time: True
    simulate_ahead_time: 2.0
    max_rotational_vel: 1.0
    min_rotational_vel: 0.4
    rotational_acc_lim: 3.2
    # param for BackUpTwzFree
    robot_radius: 0.3
    max_radius: 3.5
    service_name: "local_costmap/get_costmap"
    free_threshold: 3
    visualization: True

robot_state_publisher:
  ros__parameters:
    use_sim_time: True

waypoint_follower:
  ros__parameters:
    use_sim_time: True
    loop_rate: 20
    stop_on_failure: false
    waypoint_task_executor_plugin: "wait_at_waypoint"
    wait_at_waypoint:
      plugin: "nav2_waypoint_follower::WaitAtWaypoint"
      enabled: True
      waypoint_pause_duration: 200

velocity_smoother:
  ros__parameters:
    use_sim_time: True
    smoothing_frequency: 5.0
    scale_velocities: False
    feedback: "CLOSED_LOOP"
    max_velocity: [2.5, 2.5, 12.0]
    min_velocity: [-2.5, -2.5, -12.0]
    max_accel: [5.0, 5.0, 15.0]
    max_decel: [-5.0, -5.0, -15.0]
    odom_topic: "Odometry"
    odom_duration: 0.1
    deadband_velocity: [0.0, 0.0, 0.0]
    velocity_timeout: 1.0